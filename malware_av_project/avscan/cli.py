from __future__ import annotations
import argparse
import csv
import json
from pathlib import Path
from typing import Any, Dict, List

from rich import print
from rich.table import Table
from tqdm import tqdm

from .utils import iter_files, sha256_file
from .yara_scanner import YaraEngine
from .sigma_scanner import SigmaEngine
from .metrics import compute_confusion

def cmd_scan(args: argparse.Namespace) -> int:
    input_path = Path(args.input).expanduser()
    out_path = Path(args.out).expanduser()
    out_path.parent.mkdir(parents=True, exist_ok=True)

    report: Dict[str, Any] = {
        "meta": {
            "generated_at": args.now,
            "input": str(input_path),
            "yara_rules": str(Path(args.yara).expanduser()) if args.yara else None,
            "sigma_rules": str(Path(args.sigma).expanduser()) if args.sigma else None,
            "sigma_logs": str(Path(args.logs).expanduser()) if args.logs else None,
        },
        "files": [],
        "sigma_hits": [],
    }

    yara_engine = None
    if args.yara:
        yara_engine = YaraEngine(Path(args.yara).expanduser())

    sigma_engine = None
    if args.sigma:
        sigma_engine = SigmaEngine(Path(args.sigma).expanduser())

    file_list = list(iter_files(input_path, follow_symlinks=False))
    for fp in tqdm(file_list, desc="YARA scanning", unit="file"):
        item: Dict[str, Any] = {
            "path": str(fp),
            "name": fp.name,
            "size": fp.stat().st_size if fp.exists() else None,
            "sha256": None,
            "yara": [],
            "is_malicious": 0,
        }
        if args.hash:
            try:
                item["sha256"] = sha256_file(fp)
            except Exception:
                item["sha256"] = None

        if yara_engine:
            matches = yara_engine.scan_file(fp, timeout=args.timeout)
            item["yara"] = [
                {"rule": m.rule, "namespace": m.namespace, "tags": m.tags, "meta": m.meta}
                for m in matches
            ]
            if matches:
                item["is_malicious"] = 1

        report["files"].append(item)

    if sigma_engine and args.logs:
        log_path = Path(args.logs).expanduser()
        if log_path.exists():
            with log_path.open("r", encoding="utf-8", errors="ignore") as f:
                for i, line in enumerate(tqdm(f, desc="Sigma log scanning", unit="evt")):
                    line = line.strip()
                    if not line:
                        continue
                    try:
                        evt = json.loads(line)
                        if not isinstance(evt, dict):
                            continue
                    except Exception:
                        continue
                    hits = sigma_engine.match_event(evt)
                    if hits:
                        report["sigma_hits"].append({
                            "line": i + 1,
                            "hits": [h.__dict__ for h in hits],
                            "event_excerpt": {k: evt.get(k) for k in list(evt.keys())[:20]},
                        })

    out_path.write_text(json.dumps(report, ensure_ascii=False, indent=2), encoding="utf-8")
    print(f"[green]OK[/green] Report saved to: {out_path}")
    return 0

def cmd_metrics(args: argparse.Namespace) -> int:
    report_path = Path(args.report).expanduser()
    gt_path = Path(args.groundtruth).expanduser()
    if not report_path.exists():
        print(f"[red]Report not found:[/red] {report_path}")
        return 2
    if not gt_path.exists():
        print(f"[red]Groundtruth not found:[/red] {gt_path}")
        return 2

    report = json.loads(report_path.read_text(encoding="utf-8", errors="ignore"))
    y_pred: Dict[str, int] = {}
    for it in report.get("files", []):
        name = it.get("name")
        if name:
            y_pred[name] = int(it.get("is_malicious", 0))

    y_true: Dict[str, int] = {}
    with gt_path.open("r", encoding="utf-8", errors="ignore", newline="") as f:
        reader = csv.DictReader(f)
        for row in reader:
            n = row.get("name") or row.get("file") or row.get("filename")
            lbl = row.get("label") or row.get("malicious")
            if n is None or lbl is None:
                continue
            y_true[str(n)] = int(lbl)

    c = compute_confusion(y_true, y_pred)

    t = Table(title="Detection Metrics")
    t.add_column("Metric")
    t.add_column("Value", justify="right")
    t.add_row("TP", str(c.tp))
    t.add_row("FP", str(c.fp))
    t.add_row("FN", str(c.fn))
    t.add_row("TN", str(c.tn))
    t.add_row("Precision", f"{c.precision:.4f}")
    t.add_row("Recall", f"{c.recall:.4f}")
    t.add_row("F1", f"{c.f1:.4f}")
    t.add_row("False Positive Rate", f"{c.fpr:.4f}")
    print(t)
    return 0

def cmd_list_rules(args: argparse.Namespace) -> int:
    if args.yara:
        _ = YaraEngine(Path(args.yara).expanduser())
        print(f"[cyan]YARA compiled OK[/cyan] from {args.yara}")
    if args.sigma:
        s = SigmaEngine(Path(args.sigma).expanduser())
        print(f"[cyan]Sigma loaded[/cyan]: {len(s.rules)} rules from {args.sigma}")
        for r in s.rules[:20]:
            print(f" - {r.title} (level={r.level}, id={r.id})")
        if len(s.rules) > 20:
            print(f"... ({len(s.rules) - 20} more)")
    return 0

def build_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(
        prog="avscan",
        description="Course AV scanner: YARA file scanning + minimal Sigma log scanning + metrics",
    )
    sub = p.add_subparsers(dest="cmd", required=True)

    p_scan = sub.add_parser("scan", help="Scan files (YARA) and optionally logs (Sigma)")
    p_scan.add_argument("--input", required=True, help="File or directory to scan")
    p_scan.add_argument("--yara", default="rules/yara", help="Directory containing YARA rules (.yar/.yara)")
    p_scan.add_argument("--sigma", default=None, help="Directory containing Sigma rules (.yml/.yaml)")
    p_scan.add_argument("--logs", default=None, help="JSONL log file for Sigma scanning (optional)")
    p_scan.add_argument("--out", default="outputs/report.json", help="Path to save JSON report")
    p_scan.add_argument("--hash", action="store_true", help="Compute SHA-256 for each scanned file")
    p_scan.add_argument("--timeout", type=int, default=20, help="YARA per-file timeout (seconds)")
    p_scan.add_argument("--now", default=None, help="Override report timestamp (ISO8601)")
    p_scan.set_defaults(func=cmd_scan)

    p_m = sub.add_parser("metrics", help="Compute metrics from report + groundtruth.csv")
    p_m.add_argument("--report", required=True, help="Path to JSON report from scan")
    p_m.add_argument("--groundtruth", required=True, help="CSV with columns: name,label (1=malicious,0=benign)")
    p_m.set_defaults(func=cmd_metrics)

    p_l = sub.add_parser("list-rules", help="Verify rules can be loaded/compiled")
    p_l.add_argument("--yara", default="rules/yara", help="YARA rules dir")
    p_l.add_argument("--sigma", default=None, help="Sigma rules dir")
    p_l.set_defaults(func=cmd_list_rules)

    return p

def main(argv: List[str] | None = None) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)
    if getattr(args, "now", None) in (None, ""):
        import datetime as _dt
        args.now = _dt.datetime.now().isoformat(timespec="seconds")
    return int(args.func(args))

if __name__ == "__main__":
    raise SystemExit(main())
