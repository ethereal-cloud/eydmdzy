from __future__ import annotations
import argparse
import sys
import csv
import json
from pathlib import Path
from typing import Any, Dict, List

from rich import print
from rich.table import Table
from tqdm import tqdm

from .utils import iter_files, sha256_file
from .yara_scanner import YaraEngine
from .metrics import compute_confusion
from .zircolite_runner import find_zircolite_path, parse_zircolite_hits, run_zircolite

def cmd_scan(args: argparse.Namespace) -> int:
    input_path = Path(args.input).expanduser()
    out_path = Path(args.out).expanduser()
    out_path.parent.mkdir(parents=True, exist_ok=True)

    report: Dict[str, Any] = {
        "meta": {
            "generated_at": args.now,
            "input": str(input_path),
            "yara_rules": str(Path(args.yara).expanduser()) if args.yara else None,
            "sigma_rules": str(Path(args.sigma).expanduser()) if args.sigma else None,
            "sigma_logs": str(Path(args.logs).expanduser()) if args.logs else None,
            "zircolite": None,
        },
        "files": [],
        "sigma_hits": [],
    }

    yara_engine = None
    if args.yara:
        yara_engine = YaraEngine(Path(args.yara).expanduser())

    file_list = list(iter_files(input_path, follow_symlinks=False))
    for fp in tqdm(file_list, desc="YARA scanning", unit="file"):
        item: Dict[str, Any] = {
            "path": str(fp),
            "name": fp.name,
            "size": fp.stat().st_size if fp.exists() else None,
            "sha256": None,
            "yara": [],
            "is_malicious": 0,
        }
        if args.hash:
            try:
                item["sha256"] = sha256_file(fp)
            except Exception:
                item["sha256"] = None

        if yara_engine:
            matches = yara_engine.scan_file(fp, timeout=args.timeout)
            item["yara"] = [
                {
                    "rule": m.rule,
                    "namespace": m.namespace,
                    "rule_file": m.rule_file,
                    "tags": m.tags,
                    "meta": m.meta,
                }
                for m in matches
            ]
            if matches:
                item["is_malicious"] = 1

        report["files"].append(item)

    if args.logs and args.sigma:
        log_path = Path(args.logs).expanduser()
        rules_path = Path(args.sigma).expanduser()
        if not log_path.exists():
            print(f"[red]Log file not found:[/red] {log_path}")
            return 2
        if not rules_path.exists():
            print(f"[red]Sigma rules dir not found:[/red] {rules_path}")
            return 2
        base_dir = Path(__file__).resolve().parents[1]
        zircolite_path = Path(args.zircolite).expanduser() if args.zircolite else find_zircolite_path(base_dir)
        if not zircolite_path:
            print("[red]Zircolite not found.[/red] Set ZIRCOLITE_PATH or use --zircolite.")
            return 2
        zircolite_out = out_path.with_name(out_path.stem + "_zircolite.json")
        exit_code, output = run_zircolite(
            zircolite_path=zircolite_path,
            log_path=log_path,
            rules_path=rules_path,
            output_path=zircolite_out,
            python_exe=args.python,
        )
        report["meta"]["zircolite"] = {
            "path": str(zircolite_path),
            "output": str(zircolite_out),
            "exit_code": exit_code,
            "message": output[:5000] if output else None,
        }
        if exit_code != 0:
            print("[red]Zircolite failed.[/red] Check report meta for details.")
            return 2
        report["sigma_hits"] = parse_zircolite_hits(zircolite_out)

    out_path.write_text(json.dumps(report, ensure_ascii=False, indent=2), encoding="utf-8")
    print(f"[green]OK[/green] Report saved to: {out_path}")
    return 0

def cmd_metrics(args: argparse.Namespace) -> int:
    report_path = Path(args.report).expanduser()
    gt_path = Path(args.groundtruth).expanduser()
    if not report_path.exists():
        print(f"[red]Report not found:[/red] {report_path}")
        return 2
    if not gt_path.exists():
        print(f"[red]Groundtruth not found:[/red] {gt_path}")
        return 2

    report = json.loads(report_path.read_text(encoding="utf-8", errors="ignore"))
    y_pred: Dict[str, int] = {}
    for it in report.get("files", []):
        name = it.get("name")
        if name:
            y_pred[name] = int(it.get("is_malicious", 0))

    y_true: Dict[str, int] = {}
    with gt_path.open("r", encoding="utf-8", errors="ignore", newline="") as f:
        reader = csv.DictReader(f)
        for row in reader:
            n = row.get("name") or row.get("file") or row.get("filename")
            lbl = row.get("label") or row.get("malicious")
            if n is None or lbl is None:
                continue
            y_true[str(n)] = int(lbl)

    c = compute_confusion(y_true, y_pred)

    t = Table(title="Detection Metrics")
    t.add_column("Metric")
    t.add_column("Value", justify="right")
    t.add_row("TP", str(c.tp))
    t.add_row("FP", str(c.fp))
    t.add_row("FN", str(c.fn))
    t.add_row("TN", str(c.tn))
    t.add_row("Precision", f"{c.precision:.4f}")
    t.add_row("Recall", f"{c.recall:.4f}")
    t.add_row("F1", f"{c.f1:.4f}")
    t.add_row("False Positive Rate", f"{c.fpr:.4f}")
    print(t)
    return 0

def cmd_list_rules(args: argparse.Namespace) -> int:
    if args.yara:
        _ = YaraEngine(Path(args.yara).expanduser())
        print(f"[cyan]YARA compiled OK[/cyan] from {args.yara}")
    if args.sigma:
        rules_dir = Path(args.sigma).expanduser()
        rules = [
            p for p in rules_dir.rglob("*")
            if p.is_file() and p.suffix.lower() in {".yml", ".yaml"}
        ]
        print(f"[cyan]Sigma rules[/cyan]: {len(rules)} files under {args.sigma}")
        for p in rules[:20]:
            print(f" - {p.name}")
        if len(rules) > 20:
            print(f"... ({len(rules) - 20} more)")
    return 0

def build_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(
        prog="avscan",
        description="Course AV scanner: YARA file scanning + Zircolite EVTX scanning + metrics",
    )
    sub = p.add_subparsers(dest="cmd", required=True)

    p_scan = sub.add_parser("scan", help="Scan files (YARA) and optionally logs (Sigma)")
    p_scan.add_argument("--input", required=True, help="File or directory to scan")
    p_scan.add_argument("--yara", default="rules/yara", help="Directory containing YARA rules (.yar/.yara)")
    p_scan.add_argument("--sigma", default="rules/sigma", help="Directory containing Sigma rules (.yml/.yaml)")
    p_scan.add_argument("--logs", default=None, help="EVTX log file for Zircolite scanning (optional)")
    p_scan.add_argument("--zircolite", default=None, help="Path to zircolite.py (optional)")
    p_scan.add_argument("--python", default=sys.executable, help="Python executable for Zircolite")
    p_scan.add_argument("--out", default="outputs/report.json", help="Path to save JSON report")
    p_scan.add_argument("--hash", action="store_true", help="Compute SHA-256 for each scanned file")
    p_scan.add_argument("--timeout", type=int, default=20, help="YARA per-file timeout (seconds)")
    p_scan.add_argument("--now", default=None, help="Override report timestamp (ISO8601)")
    p_scan.set_defaults(func=cmd_scan)

    p_m = sub.add_parser("metrics", help="Compute metrics from report + groundtruth.csv")
    p_m.add_argument("--report", required=True, help="Path to JSON report from scan")
    p_m.add_argument("--groundtruth", required=True, help="CSV with columns: name,label (1=malicious,0=benign)")
    p_m.set_defaults(func=cmd_metrics)

    p_l = sub.add_parser("list-rules", help="Verify rules can be loaded/compiled")
    p_l.add_argument("--yara", default="rules/yara", help="YARA rules dir")
    p_l.add_argument("--sigma", default="rules/sigma", help="Sigma rules dir")
    p_l.set_defaults(func=cmd_list_rules)

    return p

def main(argv: List[str] | None = None) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)
    if getattr(args, "now", None) in (None, ""):
        import datetime as _dt
        args.now = _dt.datetime.now().isoformat(timespec="seconds")
    return int(args.func(args))

if __name__ == "__main__":
    raise SystemExit(main())
