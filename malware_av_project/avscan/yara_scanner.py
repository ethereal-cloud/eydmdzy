from __future__ import annotations
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List

import yara

@dataclass
class YaraMatch:
    rule: str
    namespace: str
    tags: List[str]
    meta: Dict

class YaraEngine:
    def __init__(self, rules_dir: Path):
        self.rules_dir = rules_dir
        self.rules = self._compile_rules(rules_dir)

    @staticmethod
    def _collect_rule_files(rules_dir: Path) -> Dict[str, str]:
        rule_files: Dict[str, str] = {}
        for p in rules_dir.rglob("*"):
            if p.is_file() and p.suffix.lower() in {".yar", ".yara"}:
                ns = str(p.relative_to(rules_dir)).replace("\\", "/")
                ns = ns.replace("/", "_").replace(".", "_")
                rule_files[ns] = str(p)
        return rule_files

    def _compile_rules(self, rules_dir: Path) -> yara.Rules:
        rule_files = self._collect_rule_files(rules_dir)
        if not rule_files:
            raise FileNotFoundError(
                f"No YARA rule files found under: {rules_dir} (expected .yar/.yara)"
            )
        return yara.compile(filepaths=rule_files)

    def scan_file(self, file_path: Path, timeout: int = 20) -> List[YaraMatch]:
        try:
            matches = self.rules.match(str(file_path), timeout=timeout)
        except yara.TimeoutError:
            return []
        except Exception:
            return []
        out: List[YaraMatch] = []
        for m in matches:
            out.append(
                YaraMatch(
                    rule=m.rule,
                    namespace=m.namespace,
                    tags=list(m.tags) if m.tags else [],
                    meta=dict(m.meta) if m.meta else {},
                )
            )
        return out
