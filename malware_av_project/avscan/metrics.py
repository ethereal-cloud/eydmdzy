from __future__ import annotations
from dataclasses import dataclass
from typing import Dict

@dataclass
class Confusion:
    tp: int = 0
    fp: int = 0
    fn: int = 0
    tn: int = 0

    @property
    def precision(self) -> float:
        return self.tp / (self.tp + self.fp) if (self.tp + self.fp) else 0.0

    @property
    def recall(self) -> float:
        return self.tp / (self.tp + self.fn) if (self.tp + self.fn) else 0.0

    @property
    def f1(self) -> float:
        p, r = self.precision, self.recall
        return 2 * p * r / (p + r) if (p + r) else 0.0

    @property
    def fpr(self) -> float:
        return self.fp / (self.fp + self.tn) if (self.fp + self.tn) else 0.0

def compute_confusion(y_true: Dict[str, int], y_pred: Dict[str, int]) -> Confusion:
    c = Confusion()
    keys = set(y_true.keys()) & set(y_pred.keys())
    for k in keys:
        t = int(y_true.get(k, 0))
        p = int(y_pred.get(k, 0))
        if t == 1 and p == 1:
            c.tp += 1
        elif t == 0 and p == 1:
            c.fp += 1
        elif t == 1 and p == 0:
            c.fn += 1
        else:
            c.tn += 1
    return c