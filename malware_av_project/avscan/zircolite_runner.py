from __future__ import annotations

import json
import os
import subprocess
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple


def find_zircolite_path(base_dir: Path) -> Optional[Path]:
    env_path = os.environ.get("ZIRCOLITE_PATH")
    candidates: List[Path] = []
    if env_path:
        candidates.append(Path(env_path).expanduser())
    candidates.extend(
        [
            base_dir / "tools" / "zircolite" / "zircolite.py",
            base_dir / "zircolite.py",
        ]
    )
    for path in candidates:
        if path.exists():
            return path
    return None


def run_zircolite(
    zircolite_path: Path,
    log_path: Path,
    rules_path: Path,
    output_path: Path,
    python_exe: str = "python",
) -> Tuple[int, str]:
    if log_path.suffix.lower() != ".evtx":
        raise ValueError("Zircolite runner only supports .evtx logs in this project.")
    output_path.parent.mkdir(parents=True, exist_ok=True)
    cmd = [
        python_exe,
        str(zircolite_path),
        "--evtx",
        str(log_path),
        "--ruleset",
        str(rules_path),
        "--noexternal",
        "-o",
        str(output_path),
    ]
    proc = subprocess.run(cmd, capture_output=True, text=True)
    output = (proc.stdout or "") + (proc.stderr or "")
    return proc.returncode, output.strip()


def _load_json_any(path: Path) -> List[Dict[str, Any]]:
    text = path.read_text(encoding="utf-8", errors="ignore").strip()
    if not text:
        return []
    try:
        data = json.loads(text)
        if isinstance(data, list):
            return [d for d in data if isinstance(d, dict)]
        if isinstance(data, dict):
            return [data]
    except Exception:
        pass

    items: List[Dict[str, Any]] = []
    for line in text.splitlines():
        line = line.strip()
        if not line:
            continue
        try:
            obj = json.loads(line)
        except Exception:
            continue
        if isinstance(obj, dict):
            items.append(obj)
    return items


def _get_nested(obj: Dict[str, Any], keys: List[str]) -> Any:
    cur: Any = obj
    for key in keys:
        if not isinstance(cur, dict):
            return None
        cur = cur.get(key)
    return cur


def _first_value(obj: Dict[str, Any], paths: List[List[str]]) -> Any:
    for path in paths:
        val = _get_nested(obj, path)
        if val:
            return val
    return None


def _extract_rule_hits(item: Dict[str, Any]) -> List[Dict[str, Any]]:
    hits: List[Dict[str, Any]] = []

    rules = item.get("rules")
    if isinstance(rules, list):
        for r in rules:
            if isinstance(r, dict):
                hits.append(_extract_single_rule(r))
            else:
                hits.append({"rule_title": str(r)})
        if hits:
            return hits

    hits.append(_extract_single_rule(item))
    return hits


def _extract_single_rule(item: Dict[str, Any]) -> Dict[str, Any]:
    title = _first_value(
        item,
        [
            ["rule_title"],
            ["title"],
            ["rule"],
            ["name"],
            ["sigma", "title"],
            ["sigma", "name"],
            ["rule", "title"],
            ["rule", "name"],
        ],
    )
    rule_id = _first_value(
        item,
        [
            ["rule_id"],
            ["id"],
            ["sigma", "id"],
            ["rule", "id"],
        ],
    )
    tags = _first_value(
        item,
        [
            ["tags"],
            ["sigma", "tags"],
            ["rule", "tags"],
        ],
    )
    level = _first_value(
        item,
        [
            ["level"],
            ["sigma", "level"],
            ["rule", "level"],
            ["severity"],
        ],
    )
    out: Dict[str, Any] = {"rule_title": title or "(unknown)"}
    if rule_id:
        out["rule_id"] = rule_id
    if isinstance(tags, list):
        out["tags"] = tags
    if level:
        out["level"] = level
    return out


def _extract_event_excerpt(item: Dict[str, Any]) -> Dict[str, Any]:
    for key in ("event", "data", "fields", "log"):
        val = item.get(key)
        if isinstance(val, dict):
            return {k: val.get(k) for k in list(val.keys())[:20]}

    if isinstance(item, dict):
        skip = {"sigma", "rule", "rules", "tags", "title", "rule_title", "level", "id"}
        excerpt: Dict[str, Any] = {}
        for k in list(item.keys()):
            if k in skip:
                continue
            excerpt[k] = item.get(k)
            if len(excerpt) >= 20:
                break
        return excerpt
    return {}


def parse_zircolite_hits(path: Path) -> List[Dict[str, Any]]:
    items = _load_json_any(path)
    hits_out: List[Dict[str, Any]] = []
    for idx, item in enumerate(items, start=1):
        if not isinstance(item, dict):
            continue
        hits = _extract_rule_hits(item)
        hits_out.append(
            {
                "line": idx,
                "hits": hits,
                "event_excerpt": _extract_event_excerpt(item),
            }
        )
    return hits_out
