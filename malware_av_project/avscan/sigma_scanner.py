from __future__ import annotations
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Callable, Dict, List
import re
import fnmatch
import ast

import yaml

@dataclass
class SigmaRule:
    title: str
    id: str | None
    level: str | None
    status: str | None
    logsource: Dict[str, Any]
    description: str | None
    tags: List[str]
    detection: Dict[str, Any]
    condition: str
    raw: Dict[str, Any]

@dataclass
class SigmaHit:
    rule_title: str
    rule_id: str | None
    tags: List[str]
    level: str | None

def _op_match(field_value: Any, op: str, expected: Any) -> bool:
    if field_value is None:
        return False
    if op in ("contains", "startswith", "endswith", "re"):
        fv = str(field_value)
        exps = [str(x) for x in expected] if isinstance(expected, list) else [str(expected)]
        if op == "contains":
            return any(e in fv for e in exps)
        if op == "startswith":
            return any(fv.startswith(e) for e in exps)
        if op == "endswith":
            return any(fv.endswith(e) for e in exps)
        if op == "re":
            return any(re.search(e, fv) is not None for e in exps)
    if isinstance(expected, list):
        return field_value in expected or str(field_value) in [str(x) for x in expected]
    return field_value == expected or str(field_value) == str(expected)

def _get_field(event: Dict[str, Any], field: str) -> Any:
    if field in event:
        return event[field]
    low = field.lower()
    for k, v in event.items():
        if isinstance(k, str) and k.lower() == low:
            return v
    if "." in field:
        cur: Any = event
        for part in field.split("."):
            if not isinstance(cur, dict):
                return None
            if part in cur:
                cur = cur[part]
            else:
                plow = part.lower()
                found = False
                for kk, vv in cur.items():
                    if isinstance(kk, str) and kk.lower() == plow:
                        cur = vv
                        found = True
                        break
                if not found:
                    return None
        return cur
    return None

def _build_selection_pred(selection: Dict[str, Any]) -> Callable[[Dict[str, Any]], bool]:
    tests: List[Callable[[Dict[str, Any]], bool]] = []
    for k, expected in selection.items():
        if "|" in k:
            field, op = k.split("|", 1)
        else:
            field, op = k, "eq"
        field = field.strip()
        op = op.strip().lower()

        def make_test(field=field, op=op, expected=expected):
            def _t(event: Dict[str, Any]) -> bool:
                fv = _get_field(event, field)
                if op in ("eq", "equals"):
                    return _op_match(fv, "eq", expected)
                return _op_match(fv, op, expected)
            return _t

        tests.append(make_test())

    def _pred(event: Dict[str, Any]) -> bool:
        return all(t(event) for t in tests)

    return _pred

def _safe_eval_bool_expr(expr: str, values: Dict[str, bool]) -> bool:
    def repl(m):
        name = m.group(0)
        if name in ("and", "or", "not", "True", "False"):
            return name
        if name in values:
            return "True" if values[name] else "False"
        return "False"

    py_expr = re.sub(r"\b[A-Za-z_][A-Za-z0-9_\-\*]*\b", repl, expr)
    py_expr = py_expr.replace("&&", " and ").replace("||", " or ").replace("!", " not ")

    tree = ast.parse(py_expr, mode="eval")
    for node in ast.walk(tree):
        if isinstance(node, (ast.Call, ast.Attribute, ast.Subscript, ast.Lambda, ast.Import, ast.ImportFrom)):
            raise ValueError("Unsafe expression")
    return bool(eval(compile(tree, "<sigma_condition>", "eval"), {"__builtins__": {}}, {}))

def _expand_quantifier(condition: str, keys: List[str]) -> str:
    s = re.sub(r"\s+", " ", condition).strip()

    def keys_by_pattern(pattern: str) -> List[str]:
        return [k for k in keys if fnmatch.fnmatch(k, pattern)]

    def replace_quant(m):
        quant = m.group("quant")
        scope = m.group("scope").strip()
        chosen = keys if scope == "them" else keys_by_pattern(scope)
        if not chosen:
            return "False"
        joiner = " or " if quant == "1 of" else " and "
        return "(" + joiner.join(chosen) + ")"

    s = re.sub(r"(?P<quant>1 of|all of)\s+(?P<scope>them|[A-Za-z_][A-Za-z0-9_\-\*]*)", replace_quant, s)
    return s

class SigmaEngine:
    def __init__(self, rules_dir: Path):
        self.rules_dir = rules_dir
        self.rules = self._load_rules(rules_dir)

    def _load_rules(self, rules_dir: Path) -> List[SigmaRule]:
        out: List[SigmaRule] = []
        for p in rules_dir.rglob("*"):
            if p.is_file() and p.suffix.lower() in {".yml", ".yaml"}:
                try:
                    data = yaml.safe_load(p.read_text(encoding="utf-8", errors="ignore"))
                    if not isinstance(data, dict):
                        continue
                    detection = data.get("detection", {})
                    if not isinstance(detection, dict):
                        continue
                    condition = str(detection.get("condition", "")).strip()
                    if not condition:
                        continue
                    out.append(SigmaRule(
                        title=str(data.get("title", p.stem)),
                        id=data.get("id"),
                        level=data.get("level"),
                        status=data.get("status"),
                        logsource=data.get("logsource", {}) if isinstance(data.get("logsource", {}), dict) else {},
                        description=data.get("description"),
                        tags=list(data.get("tags", [])) if isinstance(data.get("tags", []), list) else [],
                        detection=detection,
                        condition=condition,
                        raw=data
                    ))
                except Exception:
                    continue
        return out

    def match_event(self, event: Dict[str, Any]) -> List[SigmaHit]:
        hits: List[SigmaHit] = []
        for r in self.rules:
            det = r.detection
            predicates: Dict[str, Any] = {}
            for k, v in det.items():
                if k == "condition":
                    continue
                if isinstance(v, dict):
                    predicates[k] = _build_selection_pred(v)
                elif isinstance(v, list):
                    items = [x for x in v if isinstance(x, dict)]
                    item_preds = [_build_selection_pred(x) for x in items]
                    predicates[k] = lambda e, item_preds=item_preds: any(p(e) for p in item_preds)
                else:
                    predicates[k] = lambda e: False

            keys = list(predicates.keys())
            cond = _expand_quantifier(r.condition, keys)
            values = {k: bool(predicates[k](event)) for k in keys}
            try:
                ok = _safe_eval_bool_expr(cond, values)
            except Exception:
                ok = False
            if ok:
                hits.append(SigmaHit(
                    rule_title=r.title,
                    rule_id=r.id,
                    tags=r.tags,
                    level=r.level
                ))
        return hits
